if (object$shap_type == "tree"){
shap_values <- object$shap_obj$shaps
}
feature_names <- colnames(shap_values)
if (!is.null(highlight)){
if (is.numeric(highlight)){
if (all(highlight <= 1 & highlight >= nrow(shap_values))){
stop("highlighted instance id(s) not within range")
}
}
if (is.character(highlight)){
if (!all(highlight %in% feature_name)){
stop("highlighted instance(s) not valid variable name")
}
}
if (!is.character(highlight) && !is.numeric(highlight)){
stop("highlight must be a character or numeric vector")
}
}
if (!is.character(plot_title)){
stop("plot_title must be character string. see ggplot2")
}
if (!is.logical(geom_point)){
stop("geom_point must be boolean. help(plot_decisions)")
}
base_value <- mean(predict(object$final_rf, object$final_X))
prediction_out <- predict(object$final_rf, object$final_X)
feature_values <- object$final_X
shap_df <- as.data.frame(shap_values)
colnames(shap_df) <- feature_names
shap_df$Observation <- 1:nrow(shap_df)
shap_long <- melt(shap_df, id.vars = "Observation", variable.name = "Feature", value.name = "SHAP")
feature_importance <- colMeans(abs(shap_values))
feature_names <- names(sort(feature_importance, decreasing = FALSE))
shap_long$Feature <- factor(shap_long$Feature, levels = feature_names)
shap_long <- shap_long %>%
group_by(Observation) %>%
arrange(Feature) %>%
mutate(Cumulative_SHAP = cumsum(SHAP))
start <- data.frame(
Observation = 1:nrow(shap_df),
Feature = "",
SHAP = 0,
Cumulative_SHAP = 0
)
shap_long <- bind_rows(start, shap_long)
shap_long$Feature <- factor(shap_long$Feature, levels = c("", feature_names))
last_shap_values <- shap_long %>%
group_by(Observation) %>%
summarize(Last_Cumulative_SHAP = last(Cumulative_SHAP))
shap_long <- shap_long %>%
left_join(last_shap_values, by = "Observation")
if (!is.null(highlight)){
shap_long <- shap_long %>% filter(Observation %in% highlight)
}
if (geom_point == FALSE){
decision_plot <- ggplot(shap_long, aes(x = Cumulative_SHAP, y = Feature, group = Observation)) +
geom_path(aes(color = Last_Cumulative_SHAP), size = 1) +
geom_vline(xintercept = base_value, color = "#999999", linetype = "dashed") +
scale_color_gradient(low = gradient[1], high = gradient[2]) +
theme_minimal() +
labs(title = "Decision Plot",
x = "Cumulative SHAP Value",
y = "Feature",
color = "Predicted Output") +
theme(axis.text.y = element_text(size = 12), axis.text.x = element_text(size = 10))
}
if (geom_point == TRUE){
decision_plot <- ggplot(shap_long, aes(x = Cumulative_SHAP, y = Feature, group = Observation)) +
geom_path(aes(color = Last_Cumulative_SHAP), size = 1) +
geom_point(size = 2) +
geom_vline(xintercept = base_value, color = "#999999", linetype = "dashed") +
scale_color_gradient(low = gradient[1], high = gradient[2]) +
theme_minimal() +
labs(title = "Decision Plot",
x = "Cumulative SHAP Value",
y = "Feature",
color = "Predicted Output") +
theme(axis.text.y = element_text(size = 12), axis.text.x = element_text(size = 10))
}
print(decision_plot)
}
#' features.
#' @export
#' @param object   A shap_fuzzy_forest object.
#' @param main Title of plot.
#' @param xlab Title for the x axis.
#' @param ylab Title for the y axis.
#' @param module_labels Labels for the modules.  A data.frame
#'                      or character matrix with first column giving
#'                      the current name of module and second column giving
#'                      the assigned name of each module.
modplot <- function(object, main=NULL, xlab=NULL, ylab=NULL,
module_labels=NULL) {
if(is.null(main)) {
main <- "Module Membership Distribution"
}
if(is.null(xlab)) {
xlab <- "Module"
}
if(is.null(ylab)) {
ylab <- "Percentage of features in module"
}
if(!is.null(module_labels)) {
old_labels <- object$module_membership[, 2]
new_labels <- as.factor(old_labels)
module_labels <- module_labels[order(module_labels[, 1]), ]
levels(new_labels) <- module_labels[, 2]
new_labels <- as.character(new_labels)
object$module_membership[, 2] <- new_labels
select_mods <- as.factor(object$feature_list[, 3])
select_key <- module_labels[which(module_labels[, 1] %in% levels(select_mods)), ,drop=FALSE]
if( "." %in% levels(select_mods)) {
levels(select_mods)[-1] <- select_key[, 2]
}
else {
levels(select_mods) <- select_key[, 2]
}
object$feature_list[, 3] <- as.character(select_mods)
}
shap_fuzzy_forest <- object
us_modules <- shap_fuzzy_forest$final_shap$module_membership
us_modules <- us_modules[us_modules != "."]
us_modules = as.data.frame(prop.table(table(us_modules))*100)
us_modules = cbind(us_modules, rep("us", nrow(us_modules)))
names(us_modules) = c("module", "percent", "type")
df = as.data.frame(prop.table(table(shap_fuzzy_forest$module_membership[, 2]))*100)
df = cbind(df, rep("overall", nrow(df)))
names(df) = c("module", "percent", "type")
df = rbind(df
, us_modules
)
#check to see if module names are numeric, if so put them in correct order
num_test <- suppressWarnings(as.numeric(object$module_membership$module))
if(sum(is.na(num_test))==0) {
levels(df[,1]) <- as.character(sort(as.numeric(levels(df[,1]))))
}
module=5
percent=5
type=5
p_module_dist = ggplot(df
, aes(x = module
, y = percent
, fill = type)
) +
geom_bar(stat = "identity"
, position="dodge"
, colour = "#999999"
) +
labs(list(title = main
, x = xlab
, y = ylab
)) +
theme(axis.line = element_line(colour = "black")
, panel.grid.major = element_blank()
, panel.grid.minor = element_blank()
, panel.border = element_blank()
, panel.background = element_blank()
, axis.text.y = element_text(size=10)
, axis.text.x = element_text(size=10)
, axis.title = element_text(size=12, face="bold")
, plot.title = element_text(size=14, face="bold")
) +
scale_fill_manual(values = c("#CDC9C9", "#95C9FF")
, name = "Category"
, breaks=c("overall", "us")
, labels = c("Overall", "Selected Features")
) +
scale_y_continuous(expand=c(0,0))
plot(p_module_dist)
}
#' Prints output from fuzzy forests algorithm.
#' @export
#' @param x   A fuzzy_forest object.
#' @param ... Additional arguments not in use.
#' @return data.frame with list of selected features and variable
#'          importance measures.
#' @note This work was partially funded by NSF IIS 1251151.
print.shap_fuzzy_forest <- function(x, ...) {
print(x$final_SHAP)
if(!is.null(x$final_rf$test)) {
if(!is.null(x$final_rf$test$mse)) {
cat(c("test set error: ", x$final_rf$test$mse[x$final_rf$ntree]))
}
if(!is.null(x$final_rf$test$err.rate)) {
cat(c("test set error: ", x$final_rf$test$err.rate[x$final_rf$ntree]))
}
}
}
#' Obtains predictions from fuzzy forest algorithm.
#' @export
#' @param object   A fuzzy_forest object.
#' @param new_data A matrix or data.frame containing new_data.
#'                 Pay close attention to ensure feature names
#'                 match between training set and test set
#'                 data.frame.
#' @param ...      Additional arguments not in use.
#' @return A vector of predictions
#' @note This work was partially funded by NSF IIS 1251151.
predict.shap_fuzzy_forest <- function(object, new_data, ...) {
out <- predict(object$final_rf, new_data)
return(out)
}
plot_importance(madelon_ff)
library(shapviz)
plot_importance(madelon_ff)
plot_decisions(madelon_ff)
library(dplyr)
library(reshape2)
plot_decisions(madelon_ff)
#' features.
#' @export
#' @param object   A fuzzy_forest object.
#' @param main Title of plot.
#' @param xlab Title for the x axis.
#' @param ylab Title for the y axis.
#' @param module_labels Labels for the modules.  A data.frame
#'                      or character matrix with first column giving
#'                      the current name of module and second column giving
#'                      the assigned name of each module.
modplot <- function(object, main=NULL, xlab=NULL, ylab=NULL,
module_labels=NULL) {
if(is.null(main)) {
main <- "Module Membership Distribution"
}
if(is.null(xlab)) {
xlab <- "Module"
}
if(is.null(ylab)) {
ylab <- "Percentage of features in module"
}
if(!is.null(module_labels)) {
old_labels <- object$module_membership[, 2]
new_labels <- as.factor(old_labels)
module_labels <- module_labels[order(module_labels[, 1]), ]
levels(new_labels) <- module_labels[, 2]
new_labels <- as.character(new_labels)
object$module_membership[, 2] <- new_labels
select_mods <- as.factor(object$feature_list[, 3])
select_key <- module_labels[which(module_labels[, 1] %in% levels(select_mods)), ,drop=FALSE]
if( "." %in% levels(select_mods)) {
levels(select_mods)[-1] <- select_key[, 2]
}
else {
levels(select_mods) <- select_key[, 2]
}
object$feature_list[, 3] <- as.character(select_mods)
}
sff <- object
us_modules <- sff$final_SHAP$module_membership
us_modules <- us_modules[us_modules != "."]
us_modules = as.data.frame(prop.table(table(us_modules))*100)
us_modules = cbind(us_modules, rep("us", nrow(us_modules)))
names(us_modules) = c("module", "percent", "type")
df = as.data.frame(prop.table(table(sff$module_membership[, 2]))*100)
df = cbind(df, rep("overall", nrow(df)))
names(df) = c("module", "percent", "type")
df = rbind(df
, us_modules
)
#check to see if module names are numeric, if so put them in correct order
num_test <- suppressWarnings(as.numeric(object$module_membership$module))
if(sum(is.na(num_test))==0) {
levels(df[,1]) <- as.character(sort(as.numeric(levels(df[,1]))))
}
module=5
percent=5
type=5
p_module_dist = ggplot(df
, aes(x = module
, y = percent
, fill = type)
) +
geom_bar(stat = "identity"
, position="dodge"
, colour = "#999999"
) +
labs(list(title = main
, x = xlab
, y = ylab
)) +
theme(axis.line = element_line(colour = "black")
, panel.grid.major = element_blank()
, panel.grid.minor = element_blank()
, panel.border = element_blank()
, panel.background = element_blank()
, axis.text.y = element_text(size=10)
, axis.text.x = element_text(size=10)
, axis.title = element_text(size=12, face="bold")
, plot.title = element_text(size=14, face="bold")
) +
scale_fill_manual(values = c("#CDC9C9", "#95C9FF")
, name = "Category"
, breaks=c("overall", "us")
, labels = c("Overall", "Selected Features")
) +
scale_y_continuous(expand=c(0,0))
plot(p_module_dist)
}
modplot(madelon_ff)
#' features.
#' @export
#' @param object   A fuzzy_forest object.
#' @param main Title of plot.
#' @param xlab Title for the x axis.
#' @param ylab Title for the y axis.
#' @param module_labels Labels for the modules.  A data.frame
#'                      or character matrix with first column giving
#'                      the current name of module and second column giving
#'                      the assigned name of each module.
modplot <- function(object, main=NULL, xlab=NULL, ylab=NULL,
module_labels=NULL) {
if(is.null(main)) {
main <- "Module Membership Distribution"
}
if(is.null(xlab)) {
xlab <- "Module"
}
if(is.null(ylab)) {
ylab <- "Percentage of features in module"
}
if(!is.null(module_labels)) {
old_labels <- object$module_membership[, 2]
new_labels <- as.factor(old_labels)
module_labels <- module_labels[order(module_labels[, 1]), ]
levels(new_labels) <- module_labels[, 2]
new_labels <- as.character(new_labels)
object$module_membership[, 2] <- new_labels
select_mods <- as.factor(object$feature_list[, 3])
select_key <- module_labels[which(module_labels[, 1] %in% levels(select_mods)), ,drop=FALSE]
if( "." %in% levels(select_mods)) {
levels(select_mods)[-1] <- select_key[, 2]
}
else {
levels(select_mods) <- select_key[, 2]
}
object$feature_list[, 3] <- as.character(select_mods)
}
fuzzy_forest <- object
us_modules <- fuzzy_forest$feature_list$module_membership
us_modules <- us_modules[us_modules != "."]
us_modules = as.data.frame(prop.table(table(us_modules))*100)
us_modules = cbind(us_modules, rep("us", nrow(us_modules)))
names(us_modules) = c("module", "percent", "type")
df = as.data.frame(prop.table(table(fuzzy_forest$module_membership[, 2]))*100)
df = cbind(df, rep("overall", nrow(df)))
names(df) = c("module", "percent", "type")
df = rbind(df
, us_modules
)
#check to see if module names are numeric, if so put them in correct order
num_test <- suppressWarnings(as.numeric(object$module_membership$module))
if(sum(is.na(num_test))==0) {
levels(df[,1]) <- as.character(sort(as.numeric(levels(df[,1]))))
}
module=5
percent=5
type=5
p_module_dist = ggplot(df
, aes(x = module
, y = percent
, fill = type)
) +
geom_bar(stat = "identity"
, position="dodge"
, colour = "#999999"
) +
labs(list(title = main
, x = xlab
, y = ylab
)) +
theme(axis.line = element_line(colour = "black")
, panel.grid.major = element_blank()
, panel.grid.minor = element_blank()
, panel.border = element_blank()
, panel.background = element_blank()
, axis.text.y = element_text(size=10)
, axis.text.x = element_text(size=10)
, axis.title = element_text(size=12, face="bold")
, plot.title = element_text(size=14, face="bold")
) +
scale_fill_manual(values = c("#CDC9C9", "#95C9FF")
, name = "Category"
, breaks=c("overall", "us")
, labels = c("Overall", "Selected Features")
) +
scale_y_continuous(expand=c(0,0))
plot(p_module_dist)
}
modplot(madelon_ff)
knitr::opts_chunk$set(echo = TRUE)
# Load necessary libraries
library(MASS)
library(dplyr)
library(WGCNA)
library(shapff)
library(randomForest)
library(mvtnorm)
library(fuzzyforest)
library(fastshap)
options(stringsAsFactors = FALSE)
data("Boston")
target <- Boston$medv
features <- Boston %>% select(-medv)
target
data("Boston")
target <- Boston$medv
features <- Boston %>% select(-medv)
features <- Boston[,-medv]
boston
View(Boston)
features <- Boston[,-1]
View(Boston)
data("Boston")
target <- Boston$medv
View(features)
features <- Boston[,-14]
View(features)
data("Boston")
target <- Boston$medv
features <- Boston[,-14]
n <- nrow(features)
p_total <- 1000
num_original <- ncol(features)
num_additional_vars <- p_total - num_original
set.seed(123)
new_features <- features
for (i in 1:num_additional_vars) {
noise <- runif(n, min = -3, max = 3)
original_var <- sample(1:num_original, 1)
if (runif(1) < 0.33) {
new_var <- features[[original_var]] + noise
name <- colnames(features)[[original_var]]
} else if (runif(1) < 0.66) {
new_var <- features[[original_var]] + 10 * noise
name <- paste0(colnames(features)[[original_var]],"_more")
} else {
new_var <- runif(1, min = -3, max = 3)
name <- "unif"
}
new_features <- cbind(new_features, new_var)
colnames(new_features)[(i+13)] <- paste0("noise_",name,"_", i)
}
final_dataset <- bind_cols(new_features, target = target)
knitr::opts_chunk$set(echo = TRUE)
# Load necessary libraries
library(MASS)
library(dplyr)
library(WGCNA)
library(shapff)
library(randomForest)
library(mvtnorm)
library(fuzzyforest)
library(fastshap)
options(stringsAsFactors = FALSE)
data("Boston")
target <- Boston$medv
features <- Boston[,-14]
n <- nrow(features)
p_total <- 1000
num_original <- ncol(features)
num_additional_vars <- p_total - num_original
set.seed(123)
new_features <- features
for (i in 1:num_additional_vars) {
noise <- runif(n, min = -3, max = 3)
original_var <- sample(1:num_original, 1)
if (runif(1) < 0.33) {
new_var <- features[[original_var]] + noise
name <- colnames(features)[[original_var]]
} else if (runif(1) < 0.66) {
new_var <- features[[original_var]] + 10 * noise
name <- paste0(colnames(features)[[original_var]],"_more")
} else {
new_var <- runif(1, min = -3, max = 3)
name <- "unif"
}
new_features <- cbind(new_features, new_var)
colnames(new_features)[(i+13)] <- paste0("noise_",name,"_", i)
}
final_dataset <- bind_cols(new_features, target = target)
library(DT)
DT::datatable(head(final_dataset))
library(ggplot2)
library(reshape2)
cor_matrix <- cor(final_dataset)
cor_df <- as.data.frame(as.table(cor_matrix))
cor_df <- cor_df[cor_df$Var1 != cor_df$Var2, ]
cor_df <- cor_df[!duplicated(t(apply(cor_df, 1, sort))), ]
top_correlations <- cor_df[order(-abs(cor_df$Freq)), ][1:20, ]
DT::datatable(top_correlations)
data_for_wgcna <- final_dataset %>% select(-target)
screen_params <- screen_control(keep_fraction = 0.25, ntree_factor = 1, mtry_factor = 15,
min_ntree = 500)
select_params <- select_control(number_selected = 10, drop_fraction = 0.1, ntree_factor = 1,
mtry_factor = 15, min_ntree = 500)
y <- final_dataset$target
X <- final_dataset %>% select(-target)
View(final_dataset)
final_dataset[1001]
screen_params <- screen_control(keep_fraction = 0.25, ntree_factor = 1, mtry_factor = 15,
min_ntree = 500)
select_params <- select_control(number_selected = 10, drop_fraction = 0.1, ntree_factor = 1,
mtry_factor = 15, min_ntree = 500)
y <- final_dataset$target
X <- final_dataset[-1001]
boston_ff <- shapwff(X, y, select_params = select_params, screen_params = screen_params,
num_processors = 1)
datatable(boston_ff$final_SHAP)
plot_importance(boston_ff)
modplot(boston_ff)
plot_decisions(boston_ff)
