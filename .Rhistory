beta_list <- rep(c(5, 5, 2), 2)
}
if (p == 1000) {
number_of_groups <- 10
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 901:903)
vim_interest <- c(1:4, 901:904)
beta_list <- rep(c(5, 5, 2), 2)
}
for (l in 1:sim_number) {
all_modules <- lapply(1:number_of_mods, function(j) sim_mod(n, p_per_group, corr))
all_modules[[number_of_groups]] <- matrix(rnorm(p_per_group * n), nrow = n, ncol = p_per_group)
X <- do.call(cbind, all_modules)
beta <- rep(0, p_per_group * (number_of_mods + 1))
beta[vim_list] <- beta_list
y <- X %*% beta + rnorm(n, sd = 0.1)
X <- as.data.frame(X)
names(X) <- paste("V", 1:p, sep = "")
cv1 <- cv.glmnet(as.matrix(X), y, alpha = alpha)
elastic_net_model <- glmnet(as.matrix(X), y, alpha = alpha, lambda = cv1$lambda.1se)
coefs <- coef(elastic_net_model)
coefs <- as.matrix(coefs)
feature_importance <- data.frame(
Feature = rownames(coefs),
Importance = coefs[, 1]
)
feature_importance <- feature_importance[feature_importance$Feature != "(Intercept)", ]
# Order by the absolute magnitude of the importance
feature_importance <- feature_importance[order(abs(feature_importance$Importance), decreasing = TRUE), ]
# Filter out non-zero coefficients
vim <- feature_importance[1:10, ]
sim_results[[l]] <- vim
}
summarize_sim <- function(sim_results, vim_interest) {
num_interesting_feat <- length(vim_interest)
vims <- matrix(0, nrow = num_interesting_feat, ncol = length(sim_results))
selected <- matrix(0, nrow = num_interesting_feat, ncol = length(sim_results))
for (r in 1:num_interesting_feat) {
current_feature <- paste("V", vim_interest[r], sep = "")
for (t in 1:length(sim_results)) {
current_vims <- sim_results[[t]]
if (current_feature %in% current_vims[, 1]) {
current_rank <- which(current_vims[, 1] == current_feature)
vims[r, t] <- current_vims[current_rank, 2]
selected[r, t] <- 1
} else {
vims[r, t] <- 0
}
}
}
mean_vims <- apply(vims, 1, mean)
selected_props <- apply(selected, 1, mean)
sim_out <- cbind(mean_vims, selected_props)
return(sim_out)
}
out <- list(summarize_sim(sim_results, vim_interest), vim_interest, current_sim_params)
out
rep_num <- 100
alpha <- seq(0, 1, length.out = 10)
#lambda <- 10^seq(-3, 1, length.out = 10) # e.g., 0.001 to 10
p <- c(100, 1000)
n <- c(100)
param_list <- list(alpha, p, n)
param_settings <- expand.grid(param_list)
param_settings <- param_settings[, 3:1]
names(param_settings) <- c("n", "p", "alpha")
total_sim_settings <- dim(param_settings)[1]
total_sims <- rep_num * total_sim_settings
total_sims
library(mvtnorm)
library(glmnet)
rep_num <- 100
alpha <- seq(0, 1, length.out = 10)
#lambda <- 10^seq(-3, 1, length.out = 10) # e.g., 0.001 to 10
p <- c(100, 1000)
n <- c(100)
param_list <- list(alpha, p, n)
param_settings <- expand.grid(param_list)
param_settings <- param_settings[, 3:1]
names(param_settings) <- c("n", "p", "alpha")
for (id in 1:2000){
set.seed(id)
current_sim_params <- param_settings[ceiling(id/rep_num), ]
sim_number <- 5
sim_results <- list()
sim_mod <- function(n, p, corr) {
sigma <- matrix(corr, nrow = p, ncol = p)
diag(sigma) <- 1
X <- rmvnorm(n, sigma = sigma)
return(X)
}
n <- as.numeric(current_sim_params[1])
p <- as.numeric(current_sim_params[2])
alpha <- as.numeric(current_sim_params[3])
corr <- 0.8
if (p == 100) {
number_of_groups <- 4
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 76:78)
vim_interest <- c(1:4, 76:79)
beta_list <- rep(c(5, 5, 2), 2)
}
if (p == 1000) {
number_of_groups <- 10
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 901:903)
vim_interest <- c(1:4, 901:904)
beta_list <- rep(c(5, 5, 2), 2)
}
for (l in 1:sim_number) {
all_modules <- lapply(1:number_of_mods, function(j) sim_mod(n, p_per_group, corr))
all_modules[[number_of_groups]] <- matrix(rnorm(p_per_group * n), nrow = n, ncol = p_per_group)
X <- do.call(cbind, all_modules)
beta <- rep(0, p_per_group * (number_of_mods + 1))
beta[vim_list] <- beta_list
y <- X %*% beta + rnorm(n, sd = 0.1)
X <- as.data.frame(X)
names(X) <- paste("V", 1:p, sep = "")
cv1 <- cv.glmnet(as.matrix(X), y, alpha = alpha)
elastic_net_model <- glmnet(as.matrix(X), y, alpha = alpha, lambda = cv1$lambda.1se)
coefs <- coef(elastic_net_model)
coefs <- as.matrix(coefs)
feature_importance <- data.frame(
Feature = rownames(coefs),
Importance = coefs[, 1]
)
feature_importance <- feature_importance[feature_importance$Feature != "(Intercept)", ]
# Order by the absolute magnitude of the importance
feature_importance <- feature_importance[order(abs(feature_importance$Importance), decreasing = TRUE), ]
# Filter out non-zero coefficients
vim <- feature_importance[1:10, ]
sim_results[[l]] <- vim
}
summarize_sim <- function(sim_results, vim_interest) {
num_interesting_feat <- length(vim_interest)
vims <- matrix(0, nrow = num_interesting_feat, ncol = length(sim_results))
selected <- matrix(0, nrow = num_interesting_feat, ncol = length(sim_results))
for (r in 1:num_interesting_feat) {
current_feature <- paste("V", vim_interest[r], sep = "")
for (t in 1:length(sim_results)) {
current_vims <- sim_results[[t]]
if (current_feature %in% current_vims[, 1]) {
current_rank <- which(current_vims[, 1] == current_feature)
vims[r, t] <- current_vims[current_rank, 2]
selected[r, t] <- 1
} else {
vims[r, t] <- 0
}
}
}
mean_vims <- apply(vims, 1, mean)
selected_props <- apply(selected, 1, mean)
sim_out <- cbind(mean_vims, selected_props)
return(sim_out)
}
out <- list(summarize_sim(sim_results, vim_interest), vim_interest, current_sim_params)
dir.create("out9", showWarnings = FALSE)
out_filename <- paste("out9/out", id, sep = "")
save(out, file = out_filename)
}
setwd("C:/Users/timot/OneDrive/Documents/1 - UCLA/Research/shapff")
library(devtools)
library(WGCNA)
library(shapff)
library(mvtnorm)
library(fuzzyforest)
library(randomForest)
library(fastshap)
set.seed(1)
rep_num <- 100
keep_frac <- c(0.01, 0.05, 0.1, 0.15, 0.25)
drop_frac <- c(0.05, 0.1, 0.25, 0.5)
mtry_factor <- c(0.5, 1, 2)
p <- c(100,1000)
n <- c(100)
param_list <- list(keep_frac, drop_frac, mtry_factor, p, n)
param_settings <- expand.grid(param_list)
param_settings <- param_settings[, 5:1]
names(param_settings) <- c("n", "p", "mtry_factor", "drop_fraction", "keep_fraction")
current_sim_params <- param_settings[ceiling((id)/rep_num), ]
sim_number <- 5
sim_results <- list()
sim_mod <- function(n, p, corr) {
sigma <- matrix(corr, nrow = p, ncol = p)
diag(sigma) <- 1
X <- rmvnorm(n, sigma = sigma)
return(X)
}
n <- as.numeric(current_sim_params[1])
p <- as.numeric(current_sim_params[2])
mtry_factor <- as.numeric(current_sim_params[3])
keep_fraction <- as.numeric(current_sim_params[4])
drop_fraction <- as.numeric(current_sim_params[5])
corr <- 0.8
if (p == 100) {
number_of_groups <- 4
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 76:78)
vim_interest <- c(1:4, 76:79)
beta_list <- rep(c(5, 5, 2), 2)
}
if (p == 1000) {
number_of_groups <- 10
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 901:903)
vim_interest <- c(1:4, 901:904)
beta_list <- rep(c(5, 5, 2), 2)
}
runtime <- system.time({
for (l in 1:1) {
all_modules <- lapply(1:number_of_mods, function(j) sim_mod(n, p_per_group, corr))
all_modules[[number_of_groups]] <- matrix(rnorm(p_per_group * n), nrow = n, ncol = p_per_group)
X <- do.call(cbind, all_modules)
beta <- rep(0, p_per_group * (number_of_mods + 1))
beta[vim_list] <- beta_list
y <- X %*% beta + rnorm(n, sd = 0.1)
X <- as.data.frame(X)
names(X) <- paste("V", 1:p, sep = "")
mtry_factor <- 1
screen_params <- screen_control(drop_fraction = drop_fraction, keep_fraction = keep_fraction,
mtry_factor = mtry_factor)
select_params <- select_control(number_selected = 10, drop_fraction = drop_fraction,
mtry_factor = mtry_factor)
y <- as.numeric(y)
ff <- shapwff(X, y, screen_params = screen_params, select_params = select_params,
num_processors = 1, nodesize = 1)
shap_feature <- data.frame(index = ff$feature_list[1],
ff$feature_list[2], row.names = NULL)
vim <- shap_feature
sim_results[[l]] <- vim
}
})
ff
View(ff)
ff$feature_list
#' Fuzzy Forest Object
#'
#' Fuzzy forests returns an object of type
#' fuzzyforest.
#' @export
#' @param feature_list      List of selected features along with variable
#'                          importance measures.
#' @param final_rf          A final random forest fit using the features
#'                          selected by fuzzy forests.
#' @param module_membership Module membership of each feature.
#' @param WGCNA_object      If applicable, output of WGCNA analysis.
#' @param survivor_list     List of features that have survived screening step.
#' @param selection_list    List of features retained at each iteration of
#'                          selection step.
#' @return An object of type fuzzy_forest.
#' @note This work was partially funded by NSF IIS 1251151.
fuzzy_forest <- function(feature_list, final_rf, module_membership,
WGCNA_object=NULL, survivor_list, selection_list) {
out <- list()
out[[1]] <- feature_list
out[[2]] <- final_rf
out[[3]] <- module_membership
out[[4]] <- module_membership
out[[5]] <- survivor_list
out[[6]] <- selection_list
names(out) <- c("feature_list", "final_rf", "module_membership",
"WGCNA_object", "survivor_list", "selection_list")
class(out) <- "fuzzy_forest"
return(out)
}
#' Print fuzzy_forest object.
#' Prints output from fuzzy forests algorithm.
#' @export
#' @param x   A fuzzy_forest object.
#' @param ... Additional arguments not in use.
#' @return data.frame with list of selected features and variable
#'          importance measures.
#' @note This work was partially funded by NSF IIS 1251151.
print.fuzzy_forest <- function(x, ...) {
print(x$feature_list)
if(!is.null(x$final_rf$test)) {
if(!is.null(x$final_rf$test$mse)) {
cat(c("test set error: ", x$final_rf$test$mse[x$final_rf$ntree]))
}
if(!is.null(x$final_rf$test$err.rate)) {
cat(c("test set error: ", x$final_rf$test$err.rate[x$final_rf$ntree]))
}
}
}
#' Predict method for fuzzy_forest object.
#' Obtains predictions from fuzzy forest algorithm.
#' @export
#' @param object   A fuzzy_forest object.
#' @param new_data A matrix or data.frame containing new_data.
#'                 Pay close attention to ensure feature names
#'                 match between training set and test set
#'                 data.frame.
#' @param ...      Additional arguments not in use.
#' @return A vector of predictions
#' @note This work was partially funded by NSF IIS 1251151.
predict.fuzzy_forest <- function(object, new_data, ...) {
out <- predict(object$final_rf, new_data)
return(out)
}
#' Plots relative importance of modules.
#'
#' The plot is designed
#' to depict the size of each module and what percentage of selected
#' features fall into each module.  In particular, it is easy to
#' determine which module is over-represented in the group of selected
#' features.
#' @export
#' @param object   A fuzzy_forest object.
#' @param main Title of plot.
#' @param xlab Title for the x axis.
#' @param ylab Title for the y axis.
#' @param module_labels Labels for the modules.  A data.frame
#'                      or character matrix with first column giving
#'                      the current name of module and second column giving
#'                      the assigned name of each module.
modplot <- function(object, main=NULL, xlab=NULL, ylab=NULL,
module_labels=NULL) {
if(is.null(main)) {
main <- "Module Membership Distribution"
}
if(is.null(xlab)) {
xlab <- "Module"
}
if(is.null(ylab)) {
ylab <- "Percentage of features in module"
}
if(!is.null(module_labels)) {
old_labels <- object$module_membership[, 2]
new_labels <- as.factor(old_labels)
module_labels <- module_labels[order(module_labels[, 1]), ]
levels(new_labels) <- module_labels[, 2]
new_labels <- as.character(new_labels)
object$module_membership[, 2] <- new_labels
select_mods <- as.factor(object$feature_list[, 3])
select_key <- module_labels[which(module_labels[, 1] %in% levels(select_mods)), ,drop=FALSE]
if( "." %in% levels(select_mods)) {
levels(select_mods)[-1] <- select_key[, 2]
}
else {
levels(select_mods) <- select_key[, 2]
}
object$feature_list[, 3] <- as.character(select_mods)
}
fuzzy_forest <- object
us_modules <- fuzzy_forest$feature_list$module_membership
us_modules <- us_modules[us_modules != "."]
us_modules = as.data.frame(prop.table(table(us_modules))*100)
us_modules = cbind(us_modules, rep("us", nrow(us_modules)))
names(us_modules) = c("module", "percent", "type")
df = as.data.frame(prop.table(table(fuzzy_forest$module_membership[, 2]))*100)
df = cbind(df, rep("overall", nrow(df)))
names(df) = c("module", "percent", "type")
df = rbind(df
, us_modules
)
#check to see if module names are numeric, if so put them in correct order
num_test <- suppressWarnings(as.numeric(object$module_membership$module))
if(sum(is.na(num_test))==0) {
levels(df[,1]) <- as.character(sort(as.numeric(levels(df[,1]))))
}
module=5
percent=5
type=5
p_module_dist = ggplot(df
, aes(x = module
, y = percent
, fill = type)
) +
geom_bar(stat = "identity"
, position="dodge"
, colour = "#999999"
) +
labs(list(title = main
, x = xlab
, y = ylab
)) +
theme(axis.line = element_line(colour = "black")
, panel.grid.major = element_blank()
, panel.grid.minor = element_blank()
, panel.border = element_blank()
, panel.background = element_blank()
, axis.text.y = element_text(size=10)
, axis.text.x = element_text(size=10)
, axis.title = element_text(size=12, face="bold")
, plot.title = element_text(size=14, face="bold")
) +
scale_fill_manual(values = c("#CDC9C9", "#95C9FF")
, name = "Category"
, breaks=c("overall", "us")
, labels = c("Overall", "Selected Features")
) +
scale_y_continuous(expand=c(0,0))
plot(p_module_dist)
}
#' Relabel modules.
#'
#' Lets user easily re-label modules.  Modules are often labeled according to
#' color in WGCNA.  This function allows the user to rename the modules.
#' @param object        An object of type fuzzy_forest.
#' @param module_labels Labels for the modules.  A data.frame
#'                      or character matrix with first column giving
#'                      the current name of module and second column giving
#'                      the assigned name of each module.
#' @note This work was partially funded by NSF IIS 1251151.
relabel_modules <- function(object, module_labels) {
old_labels <- object$module_membership[, 2]
new_labels <- as.factor(old_labels)
module_labels <- module_labels[order(module_labels[, 1]), ]
levels(new_labels) <- module_labels[, 2]
new_labels <- as.character(new_labels)
object$module_membership[, 2] <- new_labels
return(object)
}
setwd("./shapff")
library(roxygen2)
document()
document()
setwd("..")
install("shapff")
library(WGCNA)
library(shapff)
library(mvtnorm)
library(fuzzyforest)
library(randomForest)
library(fastshap)
set.seed(1)
rep_num <- 100
keep_frac <- c(0.01, 0.05, 0.1, 0.15, 0.25)
drop_frac <- c(0.05, 0.1, 0.25, 0.5)
mtry_factor <- c(0.5, 1, 2)
p <- c(100,1000)
n <- c(100)
param_list <- list(keep_frac, drop_frac, mtry_factor, p, n)
param_settings <- expand.grid(param_list)
param_settings <- param_settings[, 5:1]
names(param_settings) <- c("n", "p", "mtry_factor", "drop_fraction", "keep_fraction")
current_sim_params <- param_settings[ceiling((id)/rep_num), ]
sim_number <- 5
sim_results <- list()
sim_mod <- function(n, p, corr) {
sigma <- matrix(corr, nrow = p, ncol = p)
diag(sigma) <- 1
X <- rmvnorm(n, sigma = sigma)
return(X)
}
n <- as.numeric(current_sim_params[1])
p <- as.numeric(current_sim_params[2])
mtry_factor <- as.numeric(current_sim_params[3])
keep_fraction <- as.numeric(current_sim_params[4])
drop_fraction <- as.numeric(current_sim_params[5])
corr <- 0.8
if (p == 100) {
number_of_groups <- 4
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 76:78)
vim_interest <- c(1:4, 76:79)
beta_list <- rep(c(5, 5, 2), 2)
}
if (p == 1000) {
number_of_groups <- 10
number_of_mods <- number_of_groups - 1
p_per_group <- p/number_of_groups
vim_list <- c(1:3, 901:903)
vim_interest <- c(1:4, 901:904)
beta_list <- rep(c(5, 5, 2), 2)
}
runtime <- system.time({
for (l in 1:1) {
all_modules <- lapply(1:number_of_mods, function(j) sim_mod(n, p_per_group, corr))
all_modules[[number_of_groups]] <- matrix(rnorm(p_per_group * n), nrow = n, ncol = p_per_group)
X <- do.call(cbind, all_modules)
beta <- rep(0, p_per_group * (number_of_mods + 1))
beta[vim_list] <- beta_list
y <- X %*% beta + rnorm(n, sd = 0.1)
X <- as.data.frame(X)
names(X) <- paste("V", 1:p, sep = "")
mtry_factor <- 1
screen_params <- screen_control(drop_fraction = drop_fraction, keep_fraction = keep_fraction,
mtry_factor = mtry_factor)
select_params <- select_control(number_selected = 10, drop_fraction = drop_fraction,
mtry_factor = mtry_factor)
y <- as.numeric(y)
ff <- shapwff(X, y, screen_params = screen_params, select_params = select_params,
num_processors = 1, nodesize = 1)
shap_feature <- data.frame(index = ff$feature_list[1],
ff$feature_list[2], row.names = NULL)
vim <- shap_feature
sim_results[[l]] <- vim
}
})
install("shapff")
remove.packages("shapff")
library(devtools)
install("shapff")
setwd("C:/Users/timot/OneDrive/Documents/1 - UCLA/Research/shapff")
library(devtools)
install("shapff")
install("shapff")
setwd(./shapff)
setwd("./shapff")
getwd()
document()
document()
document()
installed.packages()["shapff", ]
library(devtools)
